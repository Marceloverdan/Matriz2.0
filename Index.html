<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LotoEngine V7 :: Smart Control</title>
    <style>
        :root {
            --bg-body: #09090b;
            --bg-panel: #18181b;
            --bg-input: #27272a;
            --border: #3f3f46;
            --primary: #8b5cf6; /* Violeta Profissional */
            --primary-hover: #7c3aed;
            --accent: #10b981;  /* Verde Sucesso */
            --danger: #ef4444;
            --text-main: #f4f4f5;
            --text-dim: #a1a1aa;
            --font-mono: 'JetBrains Mono', 'Consolas', monospace;
            --radius: 6px;
        }

        * { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0; background-color: var(--bg-body); color: var(--text-main);
            font-family: system-ui, -apple-system, sans-serif;
            height: 100vh; display: grid; grid-template-rows: auto 1fr; overflow: hidden;
        }

        /* HEADER */
        header {
            background: var(--bg-panel); border-bottom: 1px solid var(--border);
            padding: 0.8rem 1.2rem; display: flex; justify-content: space-between; align-items: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 20;
        }
        .brand { font-weight: 800; font-size: 1.1rem; letter-spacing: -0.5px; display: flex; align-items: center; gap:8px; }
        .tag { font-size: 0.65rem; background: #3f3f46; padding: 2px 6px; border-radius: 4px; color: #fff; }

        /* LAYOUT */
        main { display: grid; grid-template-columns: 280px 1fr; height: 100%; overflow: hidden; }

        /* SIDEBAR */
        aside {
            background: var(--bg-panel); border-right: 1px solid var(--border);
            padding: 1.2rem; display: flex; flex-direction: column; gap: 1rem; overflow-y: auto;
        }

        .section-label { 
            font-size: 0.7rem; text-transform: uppercase; color: var(--primary); 
            font-weight: 800; letter-spacing: 1px; margin-top: 10px; border-bottom: 1px solid var(--border);
            padding-bottom: 4px;
        }

        .control-group { margin-bottom: 5px; }
        label { display: block; font-size: 0.75rem; color: var(--text-dim); margin-bottom: 4px; font-weight: 600; }
        
        input {
            width: 100%; background: var(--bg-input); border: 1px solid var(--border);
            color: #fff; padding: 10px; border-radius: var(--radius);
            font-family: var(--font-mono); text-align: center; font-size: 0.95rem;
            transition: 0.2s;
        }
        input:focus { border-color: var(--primary); box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.2); }

        /* INPUT ESPECIAL PARA LIMITE */
        #inpMax { border-color: var(--accent); color: var(--accent); font-weight: bold; }

        button {
            width: 100%; padding: 14px; border: none; border-radius: var(--radius);
            font-weight: 700; cursor: pointer; text-transform: uppercase; letter-spacing: 0.5px;
            margin-top: auto; transition: 0.2s;
        }
        .btn-run { background: var(--primary); color: #fff; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.25); }
        .btn-run:hover { background: var(--primary-hover); transform: translateY(-1px); }
        .btn-run:active { transform: translateY(1px); }
        .btn-run:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }

        .btn-csv { 
            background: transparent; border: 1px dashed var(--border); color: var(--text-dim); margin-top: 10px; 
            display: none; font-size: 0.8rem;
        }
        .btn-csv:hover { border-color: var(--accent); color: var(--accent); }

        /* AREA VISUAL */
        .workspace {
            display: grid; grid-template-rows: auto auto 1fr; padding: 1.5rem; gap: 1rem;
            overflow: hidden; background: radial-gradient(circle at top right, #18181b 0%, #09090b 50%);
        }

        /* METRICAS */
        .kpi-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; }
        .kpi-card {
            background: rgba(39, 39, 42, 0.6); border: 1px solid var(--border);
            padding: 10px; border-radius: var(--radius); text-align: center;
        }
        .kpi-val { font-family: var(--font-mono); font-size: 1.25rem; font-weight: 700; color: #fff; }
        .kpi-lbl { font-size: 0.65rem; text-transform: uppercase; color: var(--text-dim); margin-top: 4px; }
        
        .val-coverage { color: var(--accent); }

        /* CONSOLE & PROGRESSO */
        .feedback-area { display: flex; flex-direction: column; gap: 8px; }
        
        .progress-track { height: 6px; background: var(--bg-input); border-radius: 3px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--primary); width: 0%; transition: width 0.3s; }

        .log-box {
            font-family: var(--font-mono); font-size: 0.75rem; color: var(--text-dim);
            height: 20px; display: flex; align-items: center; white-space: nowrap; overflow: hidden;
        }

        /* TABELA */
        .table-wrap {
            border: 1px solid var(--border); border-radius: var(--radius); background: var(--bg-panel);
            overflow: auto; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.2);
        }
        table { width: 100%; border-collapse: collapse; font-family: var(--font-mono); font-size: 0.9rem; }
        th { 
            background: #111; position: sticky; top: 0; padding: 12px; text-align: left;
            color: var(--text-dim); font-size: 0.7rem; text-transform: uppercase; border-bottom: 1px solid var(--border);
            z-index: 10;
        }
        td { padding: 8px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        tr:nth-child(even) { background: rgba(255,255,255,0.01); }

        .ball {
            display: inline-flex; width: 26px; height: 26px; align-items: center; justify-content: center;
            border-radius: 50%; background: #27272a; margin-right: 3px; font-size: 0.8rem; font-weight: 700;
            border: 1px solid #3f3f46; box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        }

        /* MOBILE */
        @media (max-width: 768px) {
            body { display: block; overflow-y: auto; }
            main { display: block; }
            aside { border-right: none; border-bottom: 1px solid var(--border); }
            .kpi-grid { grid-template-columns: 1fr 1fr; }
            .workspace { height: 600px; padding: 1rem; }
        }
    </style>
</head>
<body>

<header>
    <div class="brand">
        <span style="color:var(--primary)">LOTO</span>ENGINE <span class="tag">V7 CONTROL</span>
    </div>
</header>

<main>
    <aside>
        <div class="section-label">Parâmetros Matemáticos</div>
        <div class="control-group">
            <label>Total Dezenas (N)</label>
            <input type="number" id="inpN" value="25">
        </div>
        <div class="control-group">
            <label>Dezenas por Jogo (K)</label>
            <input type="number" id="inpK" value="15">
        </div>
        <div class="control-group">
            <label>Condição Acerto (C)</label>
            <input type="number" id="inpC" value="14">
        </div>
        <div class="control-group">
            <label>Garantia (G)</label>
            <input type="number" id="inpG" value="14">
        </div>

        <div class="section-label" style="margin-top: 20px;">Orçamento (Filtro)</div>
        <div class="control-group">
            <label style="color:var(--accent)">MÁXIMO DE JOGOS</label>
            <input type="number" id="inpMax" value="10" min="1" placeholder="Ex: 10">
        </div>

        <button class="btn-run" id="btnRun" onclick="Controller.start()">PROCESSAR AGORA</button>
        <button class="btn-csv" id="btnCsv" onclick="Controller.export()">BAIXAR CSV</button>
    </aside>

    <div class="workspace">
        <div class="kpi-grid">
            <div class="kpi-card">
                <div class="kpi-val" id="dispGames">0</div>
                <div class="kpi-lbl">Jogos Gerados</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-val val-coverage" id="dispCover">0%</div>
                <div class="kpi-lbl">Força (Cobertura)</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-val" id="dispUniverse">0</div>
                <div class="kpi-lbl">Cenários Totais</div>
            </div>
            <div class="kpi-card">
                <div class="kpi-val" id="dispTime">0s</div>
                <div class="kpi-lbl">Tempo</div>
            </div>
        </div>

        <div class="feedback-area">
            <div class="progress-track">
                <div class="progress-fill" id="progressBar"></div>
            </div>
            <div class="log-box" id="consoleLog">> Aguardando configuração...</div>
        </div>

        <div class="table-wrap">
            <table id="resTable">
                <thead>
                    <tr><th width="50">#</th><th>COMBINAÇÃO OTIMIZADA</th></tr>
                </thead>
                <tbody id="resBody"></tbody>
            </table>
        </div>
    </div>
</main>

<script id="worker-code" type="javascript/worker">
/**
 * WORKER DE ALTA PERFORMANCE V7
 * Foco: Maximizar cobertura dentro de um limite fixo de jogos.
 */

// Math Utils
function combinationsCount(n, k) {
    if (k < 0 || k > n) return 0;
    if (k == 0 || k == n) return 1;
    if (k > n / 2) k = n - k;
    let res = 1;
    for (let i = 1; i <= k; i++) res = res * (n - i + 1) / i;
    return res;
}

// Bitmask Utils (BigInt)
const toMask = (arr) => arr.reduce((acc, n) => acc | (1n << BigInt(n-1)), 0n);
const popCount = (n) => {
    let c = 0;
    while(n > 0n) { n &= (n - 1n); c++; }
    return c;
};
const fromMask = (m, n) => {
    let res = [];
    for(let i=0; i<n; i++) if(m & (1n << BigInt(i))) res.push(i+1);
    return res;
};

self.onmessage = function(e) {
    const { N, K, C, G, maxGames } = e.data;
    const startT = Date.now();

    try {
        self.postMessage({ type: 'log', text: 'Mapeando universo combinatório...' });

        // 1. Gera ou Amostra o Universo (Cenários a cobrir)
        const totalSize = combinationsCount(N, C);
        const MAX_EXACT = 300000;
        let universe = [];
        let isSampled = false;

        // Função geradora de combinações
        function* genCombos(n, k) {
            const arr = Array.from({length:k}, (_,i)=>i+1);
            yield arr.slice();
            while(true) {
                let i = k - 1;
                while(i >= 0 && arr[i] == n - k + i + 1) i--;
                if(i < 0) break;
                arr[i]++;
                for(let j=i+1; j<k; j++) arr[j] = arr[j-1] + 1;
                yield arr.slice();
            }
        }

        if (totalSize <= MAX_EXACT) {
            for (const c of genCombos(N, C)) universe.push(toMask(c));
        } else {
            isSampled = true;
            self.postMessage({ type: 'log', text: 'Universo vasto: usando amostragem estatística.' });
            const sampleSize = 100000;
            const seen = new Set();
            let safe = 0;
            while(universe.length < sampleSize && safe < 500000) {
                const pool = Array.from({length:N}, (_,i)=>i+1);
                // Fisher-Yates parcial
                for(let i=0; i<C; i++) {
                    const r = i + Math.floor(Math.random() * (N - i));
                    [pool[i], pool[r]] = [pool[r], pool[i]];
                }
                const m = toMask(pool.slice(0,C));
                if(!seen.has(m)) {
                    seen.add(m);
                    universe.push(m);
                }
                safe++;
            }
        }

        const universeSizeInitial = universe.length;
        self.postMessage({ type: 'stats', universe: isSampled ? totalSize : universeSizeInitial });

        // 2. OTIMIZAÇÃO GULOSA (BEST-FIT)
        // O objetivo é encontrar o jogo que cobre o MAIOR número de cenários restantes
        // Repetir até atingir o limite de jogos ou cobertura total.

        let solution = [];
        let uncovered = [...universe]; // Working set

        self.postMessage({ type: 'log', text: 'Calculando jogos mais eficientes...' });

        while (uncovered.length > 0 && solution.length < maxGames) {
            
            // Para ser "Enxuto", precisamos do melhor jogo possível nesta iteração.
            // Heurística: Pega um cenário não coberto e tenta expandí-lo para K números
            // de forma que cubra o máximo de outros cenários.
            
            let bestMask = 0n;
            let bestHits = -1;
            
            // Número de tentativas para encontrar o melhor jogo "da vez"
            // Quanto mais tentativas, mais compacta a matriz (mas mais lento)
            const attempts = 300; 
            
            // Focamos nos cenários restantes (target)
            // Pegamos aleatoriamente alguns alvos difíceis para basear a busca
            
            for(let t=0; t<attempts; t++) {
                // Pega um cenário aleatório dos que SOBRARAM (isso força o algoritmo a resolver o problema)
                const targetIdx = Math.floor(Math.random() * uncovered.length);
                const targetMask = uncovered[targetIdx];
                const targetArr = fromMask(targetMask, N);
                
                // Completa com números aleatórios que não estão no target
                const remainingNums = Array.from({length:N}, (_,i)=>i+1).filter(x => !targetArr.includes(x));
                
                // Shuffle simples nos restantes
                for (let i = remainingNums.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [remainingNums[i], remainingNums[j]] = [remainingNums[j], remainingNums[i]];
                }
                
                // Monta candidato
                const fillNeeded = K - targetArr.length;
                let candidateArr;
                
                if (fillNeeded > 0) {
                     candidateArr = targetArr.concat(remainingNums.slice(0, fillNeeded));
                } else {
                     candidateArr = targetArr.slice(0, K); // Caso C > K (raro)
                }
                
                const candMask = toMask(candidateArr);
                
                // Avalia: Quantos do 'uncovered' este candMask mata?
                let hits = 0;
                // Amostragem de verificação para performance
                const checkStep = uncovered.length > 5000 ? 5 : 1;
                
                for(let u=0; u<uncovered.length; u+=checkStep) {
                    if (popCount(candMask & uncovered[u]) >= G) hits++;
                }
                
                if (hits > bestHits) {
                    bestHits = hits;
                    bestMask = candMask;
                }
            }
            
            if (bestHits <= 0) {
                // Fallback de segurança se travar
                break;
            }

            solution.push(bestMask);
            
            // Remove os cobertos
            uncovered = uncovered.filter(u => popCount(bestMask & u) < G);
            
            // Progresso Visual
            const pct = Math.round((solution.length / maxGames) * 100);
            const coverage = ((universeSizeInitial - uncovered.length) / universeSizeInitial) * 100;
            
            if (solution.length % 2 === 0 || solution.length === maxGames) {
                self.postMessage({ 
                    type: 'progress', 
                    pct: pct, 
                    realCoverage: coverage,
                    games: solution.length
                });
            }
        }

        // Finaliza
        const finalCoverage = ((universeSizeInitial - uncovered.length) / universeSizeInitial) * 100;
        const resultGames = solution.map(m => fromMask(m, N).sort((a,b)=>a-b));
        
        // Ordenação Visual da Matriz
        resultGames.sort((a,b) => {
             for(let i=0; i<a.length; i++) if(a[i]!==b[i]) return a[i]-b[i];
             return 0;
        });

        self.postMessage({ 
            type: 'done', 
            games: resultGames, 
            coverage: finalCoverage,
            time: Date.now() - startT
        });

    } catch (err) {
        self.postMessage({ type: 'error', msg: err.message });
    }
};
</script>

<script>
const Controller = {
    worker: null,
    data: [],

    init: function() {
        const blob = new Blob([document.getElementById('worker-code').textContent], {type: 'text/javascript'});
        this.workerUrl = URL.createObjectURL(blob);
    },

    start: function() {
        const N = parseInt(document.getElementById('inpN').value);
        const K = parseInt(document.getElementById('inpK').value);
        const C = parseInt(document.getElementById('inpC').value);
        const G = parseInt(document.getElementById('inpG').value);
        const maxGames = parseInt(document.getElementById('inpMax').value);

        if (!maxGames || maxGames < 1) return alert("Defina um limite de jogos válido!");
        if (K > N) return alert("K não pode ser maior que N");

        // UI Reset
        this.setRunning(true);
        document.getElementById('resBody').innerHTML = '';
        document.getElementById('dispCover').innerText = '0%';
        document.getElementById('dispGames').innerText = '0';
        document.getElementById('progressBar').style.width = '0%';
        this.data = [];

        if (this.worker) this.worker.terminate();
        this.worker = new Worker(this.workerUrl);

        this.worker.postMessage({ N, K, C, G, maxGames });

        this.worker.onmessage = (e) => {
            const d = e.data;
            if (d.type === 'log') this.log(d.text);
            if (d.type === 'stats') {
                document.getElementById('dispUniverse').innerText = d.universe > 1000000 ? '>1M' : d.universe.toLocaleString();
            }
            if (d.type === 'progress') {
                document.getElementById('progressBar').style.width = d.pct + '%';
                document.getElementById('dispGames').innerText = d.games;
                document.getElementById('dispCover').innerText = d.realCoverage.toFixed(2) + '%';
            }
            if (d.type === 'done') {
                this.finish(d);
            }
            if (d.type === 'error') {
                this.log("ERRO: " + d.msg);
                this.setRunning(false);
            }
        };
    },

    finish: function(d) {
        this.data = d.games;
        this.setRunning(false);
        document.getElementById('progressBar').style.width = '100%';
        document.getElementById('dispTime').innerText = (d.time / 1000).toFixed(1) + 's';
        document.getElementById('dispCover').innerText = d.coverage.toFixed(3) + '%';
        this.log(`Concluído. Cobertura final: ${d.coverage.toFixed(2)}% com ${d.games.length} jogos.`);
        
        this.renderTable(d.games);
        document.getElementById('btnCsv').style.display = 'inline-block';
    },

    renderTable: function(games) {
        const tbody = document.getElementById('resBody');
        let html = '';
        const limit = 100;
        
        games.slice(0, limit).forEach((row, i) => {
            const balls = row.map(n => `<span class="ball">${n}</span>`).join('');
            html += `<tr>
                <td style="color:var(--text-dim);">${i+1}</td>
                <td>${balls}</td>
            </tr>`;
        });
        
        if (games.length > limit) {
            html += `<tr><td colspan="2" style="text-align:center; color:var(--text-dim); padding:10px;">... + ${games.length - limit} jogos ocultos ...</td></tr>`;
        }
        tbody.innerHTML = html;
    },

    export: function() {
        if (!this.data.length) return;
        let csv = "ID;Bolas\n";
        this.data.forEach((row, i) => {
            csv += `${i+1};${row.join(';')}\n`;
        });
        const url = URL.createObjectURL(new Blob([csv], {type:'text/csv'}));
        const a = document.createElement('a');
        a.href = url;
        a.download = 'LotoEngine_V7.csv';
        a.click();
    },

    log: function(msg) {
        document.getElementById('consoleLog').innerText = "> " + msg;
    },

    setRunning: function(active) {
        const btn = document.getElementById('btnRun');
        if (active) {
            btn.disabled = true;
            btn.innerText = "CALCULANDO...";
            document.getElementById('btnCsv').style.display = 'none';
        } else {
            btn.disabled = false;
            btn.innerText = "PROCESSAR AGORA";
        }
    }
};

Controller.init();
</script>
</body>
</html>
